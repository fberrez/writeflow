---
alwaysApply: true
---
# WriteFlow - Addictive Writing App

You are an expert AI programming assistant working on WriteFlow, an addictive writing app that gamifies the writing experience through immediate feedback, satisfying audio cues, and gentle constraints.

## Project Overview

WriteFlow is a React + TypeScript application built with Vite in a Turborepo monorepo structure. The app focuses on creating an immersive, flow-state writing experience through:

- **Satisfying audio feedback** using Web Audio API
- **Visual particle effects** that follow the user's cursor precisely
- **Gamification elements** like daily goals, streaks, and progress tracking
- **Focus modes** that eliminate distractions and encourage forward momentum
- **Beautiful, distraction-free UI** with glassmorphism design

## Architecture

### Tech Stack
- **Frontend**: React 18 + TypeScript + Vite
- **Styling**: Tailwind CSS with custom animations
- **Monorepo**: Turborepo for project management
- **Audio**: Web Audio API for real-time sound synthesis
- **State Management**: React hooks (useState, useCallback, useEffect, useRef)

### Project Structure
```
writeflow/
├── apps/frontend/          # Main React application
│   ├── src/
│   │   ├── components/     # React components
│   │   ├── hooks/          # Custom React hooks
│   │   ├── types/          # TypeScript interfaces
│   │   ├── utils/          # Utility functions
│   │   └── App.tsx         # Main app component
│   └── public/celebrate.mp3 # Goal celebration sound
├── packages/               # Shared configurations
└── README.md
```

## Core Features & Implementation

### 1. Audio System (`useAudio.ts`)
- **5 Sound Types**: Pop, Click, Chime, Drop, Random
- **Web Audio API**: Real-time synthesis with oscillators, filters, and envelopes
- **Browser Compatibility**: Handles audio context policies and user interaction requirements
- **Volume Control**: Adjustable gain nodes with test functionality

### 2. Particle System (`useParticles.ts`)
- **Cursor Tracking**: Particles appear exactly where the user types
- **Text Wrapping**: Handles line breaks and text overflow correctly
- **Boundary Clipping**: Particles stay within textarea boundaries
- **Celebration Mode**: Explosive confetti burst from cursor on goal completion
- **Performance**: Automatic cleanup and memory management

### 3. Writing Stats (`useWritingStats.ts`)
- **Real-time Counting**: Word count, character count, session duration
- **Daily Goals**: Configurable targets with progress tracking
- **Streak System**: Consecutive writing days (placeholder for future persistence)
- **Progress Animation**: Smooth progress bar updates

### 4. Focus Modes (`useWritingModes.ts`)
- **Redact Mode**: CSS blur filter to hide written text
- **No-Delete Mode**: Prevents backspace/delete key functionality
- **No-Copy/Paste Mode**: Blocks clipboard operations
- **Keyboard Event Handling**: Intercepts and prevents specific key combinations

### 5. Goal Celebration (`useGoalCelebration.ts`)
- **Audio Playback**: Plays celebrate.mp3 on goal completion
- **Confetti Trigger**: Initiates particle explosion at cursor position
- **Session Tracking**: Prevents multiple celebrations per session
- **Volume Control**: Automatic audio level management

## UI Components

### WritingArea (`WritingArea.tsx`)
- **Textarea Management**: Full-screen writing interface with monospace font
- **Cursor Position Calculation**: Precise measurement using temporary DOM elements
- **Particle Positioning**: Accurate placement considering text wrapping and scrolling
- **Event Handling**: Keyboard events, clipboard operations, focus management

### StatsDisplay (`StatsDisplay.tsx`)
- **Real-time Updates**: Live display of writing metrics
- **Progress Visualization**: Animated progress bars and counters
- **Conditional Rendering**: Can be hidden via settings
- **Icon Integration**: Lucide React icons for visual appeal

### SettingsPanel (`SettingsPanel.tsx`)
- **Slide-out Panel**: Smooth animation from right edge
- **Sound Selection**: Dropdown for choosing audio types with emojis
- **Toggle Controls**: Custom switches for various modes
- **Keyboard Shortcuts**: Enter key to close after goal changes

## Design Principles

### User Experience
- **Immediate Feedback**: Every keystroke should feel satisfying
- **Flow State**: Minimize interruptions and maximize writing momentum
- **Gamification**: Progress tracking without being overwhelming
- **Accessibility**: Keyboard shortcuts and clear visual hierarchy

### Code Quality
- **TypeScript**: Strict typing throughout the application
- **React Patterns**: Proper hook usage, memoization, and lifecycle management
- **Performance**: Efficient particle systems and audio handling
- **Error Handling**: Graceful degradation when features fail

### Visual Design
- **Zen Aesthetic**: Clean, minimal interface with gentle colors
- **Glassmorphism**: Frosted glass effects with backdrop blur
- **Smooth Animations**: 60fps particle effects and UI transitions
- **Typography**: JetBrains Mono for professional writing experience

## Development Guidelines

### Code Style
- Use TypeScript interfaces for all props and state
- Prefer `useCallback` and `useMemo` for performance optimization
- Follow React hooks rules and dependencies
- Use Tailwind CSS classes with semantic naming
- Add JSDoc comments for complex functions

### Audio Implementation
- Always handle browser audio policies (user interaction required)
- Use `try/catch` blocks for Web Audio API calls
- Implement volume controls and mute functionality
- Test across different browsers for compatibility

### Particle System
- Ensure particles respect container boundaries
- Handle text wrapping and scrolling correctly
- Clean up particles automatically to prevent memory leaks
- Use CSS transforms for smooth animations

### State Management
- Keep state as local as possible
- Use refs for values that don't trigger re-renders
- Implement proper cleanup in useEffect hooks
- Handle edge cases like rapid state changes

## Common Issues & Solutions

### Audio Problems
- **No Sound**: Check browser audio policies, ensure user interaction
- **Delayed Audio**: Reduce buffer sizes, optimize synthesis
- **Browser Compatibility**: Test in Chrome, Firefox, Safari

### Particle Alignment
- **Cursor Mismatch**: Verify font metrics and padding calculations
- **Text Wrapping**: Use proper DOM measurement techniques
- **Boundary Issues**: Implement clipping and position clamping

### Performance
- **Memory Leaks**: Ensure particle cleanup and event listener removal
- **Frame Drops**: Optimize animation loops and reduce particle count
- **Bundle Size**: Use dynamic imports for large dependencies

## Future Enhancements
- **Local Storage**: Persist settings and writing sessions
- **Backend Integration**: User accounts and cloud sync
- **Mobile Support**: Touch-optimized interface
- **Themes**: Multiple color schemes and customization
- **Export Features**: Save writing to various formats

## Testing Strategy
- **Manual Testing**: Cross-browser compatibility and feature validation
- **Performance Testing**: Memory usage and frame rate monitoring
- **Accessibility Testing**: Keyboard navigation and screen reader support
- **Audio Testing**: Various devices and browser configurations

Remember: WriteFlow is about creating an addictive, joyful writing experience. Every feature should contribute to the flow state and make writing feel satisfying and rewarding.
